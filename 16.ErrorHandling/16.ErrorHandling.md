# 16.Error Handling

### Never

- Failure 타입이 Never이면 publisher가 절대 fail하지 않음을 나타냄(에러를 방출하지 않음)

![Untitled](16%20Error%20Handling%206443bf8412334c7c9f5407d8bf755e16/Untitled.png)

- Just가 이에 해당함
    
    ```swift
    
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public struct Just<Output> : Publisher {
    
        /// The kind of errors this publisher might publish.
        ///
        /// Use `Never` if this `Publisher` does not publish errors.
        public typealias Failure = Never
    
        /// The one element that the publisher emits.
        public let output: Output
    }
    ```
    
- Failure = Never인 경우 value만 받는 sink(receieveValue:) 오퍼레이터를 제공

### setFailureType

- 오류가 없는 publisher를 오류가 있는 publisher로 바꾸는 방법
- publisher의 failure 타입이 Never인 경우에만 사용가능
- `setFailureType` 을 적용한 후 erase를 하려고하면 Failure = MyError로 바뀐것을 볼 수 있다.

![Untitled](16%20Error%20Handling%206443bf8412334c7c9f5407d8bf755e16/Untitled%201.png)

- MyError타입으로 Failure가 설정되었기 때문에 sink쪽에서 completion을 받을 때 completion case 중 failure에서 바로 MyError타입을 받을 수 있음(캐스팅 불필요)

```swift
enum MyError: Error {
	case ohNo
}

example(of: "setFailrueType") {
    Just("Hello")
        .setFailureType(to: MyError.self)
        .sink(
            receiveCompletion: { completion in
                switch completion {
                case .failure(.ohNo):
                    print("Finished with Oh no!")
                case .finished:
                    print("Finished successfully")
                    
                }
            },
            receiveValue: { value in
            print("Got value: \(value)")
            }
        )
        .store(in: &subscriptions)
}

// Got value: Hello
// Finished successfully
```

### assign(to:on:)

- assign을 통해 key path에 에러를 보내면 처리되지 않는 오류나 정의되지 않는 동작이 발생함 (unhandled error or undefined behavior)
- 아래 코드는 Just가 Failure = Never 기 때문에 아무 이상없이 잘 동작함

```swift
example(of: "assign(to:on:)") {
    class Person {
        let id = UUID()
        var name = "Unknown"
    }
    
    let person = Person()
    print("1", person.name)
    
    Just("Shai")
        .handleEvents(
            // completion이기 때문에 person.name이 Shai가 찍힘
            receiveCompletion: { _ in print("2", person.name) }
        )
        .assign(to: \.name, on: person)
        .store(in: &subscriptions)
}
/*
——— Example of: assign(to:on:) ———
1 Unknown
2 Shai
*/
```

- setFailureType을 통해 에러타입을 정의해주면 아래와 같은 컴파일 에러 발생

![Untitled](16%20Error%20Handling%206443bf8412334c7c9f5407d8bf755e16/Untitled%202.png)

### assign(to:)

- Output: 최초값 + 타이머 3번 발생

```swift
example(of: "assign(to:)") {
    class MyViewModel: ObservableObject {
        @Published var currentDate = Date()
        
        init() {
            Timer.publish(every: 1, on: .main, in: .common)
                .autoconnect()
                .prefix(3)
                .assign(to: \.currentDate, on: self)
                .store(in: &subscriptions)
        }
    }
    
    let vm = MyViewModel()
    vm.$currentDate
        .sink(receiveValue: { print($0) })
        .store(in: &subscriptions)
}
/*
——— Example of: assign(to:) ———
2023-05-29 02:51:12 +0000
2023-05-29 02:51:13 +0000
2023-05-29 02:51:14 +0000
2023-05-29 02:51:15 +0000
*/
```

- 여기서 잠깐 오래만에 Timer Mode 정리
    - Timer RunLoop Mode
        - .common : 실행 루프의 기본 모드. 타이머가 기본 실행 루프에서 처리된다. 타이머 이벤트를 처리하는 동안 다른 높은 우선순위의 작업이 실행될 수 있음
        - .default : 타이머 이벤트가 RunLoop에서 처리된다. 이 모드는 타이머가 이벤트를 처리하는 동안 다른 동시 작업이 실행되지 않는다. 타이머 이벤트가 완료되어야 다음 작업이 실행된다.
        - iOS 앱 → 메인스레드에서 실행되는 루프 → 기본 실행 루프 → .common
        - Timer.Publisher가 메인스레드에서 사용되는 경우 common모드
        - default모드를 사용하려면 RunLoop.current 속성을 통해 다른 실행루프를 사용하거나 백그라운드에서 Timer.Publisher를 실행해야함.
- 위의 코드는 문제가 있음!!!!
    - assign(to:on:) 은 self에 대해서 강한 참조를 하는 subscription을 만들어낸다. (=self가 subscription에 대해 강한참조가 걸려있는 상태)
    - subscriptions는 self에 참조되어있다. → **순환참조**
    
    ![Untitled](16%20Error%20Handling%206443bf8412334c7c9f5407d8bf755e16/Untitled%203.png)
    
- `assign(to:)`
    - retain cycle 해결
    - 이를 해결하기 위한 오버로드 버전 연산자.
    - @Published 프로퍼티에 발행된 값들을 다시 할당하기 위해 해당 프로퍼티의 projected publisher에 대한 inout 참조를 제공한다.
    - 참고로 프로퍼티래퍼에서 `projectedValue`에 접근하려면 $를 붙이면된다.
    - `.assign(to: \.currentDate, on: **self**)` → `.assign(to: &$currentDate)`
    - 내부적으로 subscription에 대한 메모리 관리도 자동으로 처리하므로 store(in:&subscription)이 필요 없음 → 반환값 자체가 없음

```swift
example(of: "assign(to:)") {
    class MyViewModel: ObservableObject {
        @Published var currentDate = Date()
        
        init() {
            Timer.publish(every: 1, on: .main, in: .common)
                .autoconnect()
                .prefix(3)
                .assign(to: &$currentDate) // 반환값자체가 없음
        }
    }
    
    let vm = MyViewModel()
    vm.$currentDate
        .sink(receiveValue: { print($0) })
        .store(in: &subscriptions)
}
```

### assertNoFailure

- 개발 중에 에러로 스트림이 끝나지 않음을 확인할 때 유용
- 업스트림에서 에러가 흐르는 것을 막을 수는 없지만 에러가 흐르면 fatalError로 크래시를 발생시킨다.
- 다시 publisher의 failure 타입을 Never로 바꾼다. (다운스트림에 Never)

```swift
example(of: "assertNoFailure") {
    Just("Hello")
        .setFailureType(to: MyError.self)
        .tryMap { _ in throw MyError.ohNo }
        .assertNoFailure()
        .sink(receiveValue: { print("Got value: \($0)") })
        .store(in: &subscriptions)
}
```

## Dealing with failure

Combine에서 `try`로 시작하는 연산자는 에러와 관련하여 동일한 방식으로 동작한다. 

### tryMap

- 아래 코드는 map으로 진행할 경우 컴파일 에러가 뜬다. map은 non-throwing operator이기 때문. → tryMap으로 바꿔서 진행
- 에러 발생

```swift
example(of: "tryMap") {
    enum NameError: Error {
        case tooShort(String)
        case unknown
    }
    
    let names = ["Marin", "Shai", "Florent"].publisher
    
    names
	 			.tryMap { value in
//        .map { value in // No exact matches in call to instance method 'map'
            let length = value.count
            
            guard length >= 5 else {
                throw NameError.tooShort(value)
            }
            
            return value.count
        }
        .sink(receiveCompletion: { print("Completed with \($0)") },
              receiveValue: { print("Got value: \($0)") })
}

/*
Output
----------
Completed with failure(__lldb_expr_56.
(unknown context at $1047f88dc).
(unknown context at $1047f88e4).
(unknown context at $1047f88ec).
NameError.tooShort("Shai"))
*/
```

### Mapping errors

map은 현재 failure type을 그대로 유지하면서 value만 조작할 수 있는 반면, tryMap은 그렇지않다. 실제 에러타입을 Swift Error타입으로 지운다.(erases the error type to a plain Swift Error)

- map일 때 completion 타입 : `Subscribers.Completion<**NameError**>`
- tryMap일 때 completion 타입: `Subscribers.Completion<**Error**>`
    - NameError → Error 로 위에서 말한 에러타입을 지움

```swift
example(of: "map vs tryMap") {
  enum NameError: Error {
    case tooShort(String)
    case unknown
  }

  Just("Hello")
    .setFailureType(to: NameError.self)
    .map { $0 + " World!" }
    .sink(
      receiveCompletion: { completion in
        switch completion {
        case .finished:
          print("Done!")
        case .failure(.tooShort(let name)):
          print("\(name) is too short!")
        case .failure(.unknown):
          print("An unknown name error occurred")
        }
      },
      receiveValue: { print("Got value \($0)") }
    )
    .store(in: &subscriptions)
}

example(of: "map vs tryMap") {
  enum NameError: Error {
    case tooShort(String)
    case unknown
  }

  Just("Hello")
    .setFailureType(to: NameError.self)
    .tryMap { $0 + " World!" }
    .sink(receiveCompletion: { completion in
        switch completion {
        case .finished:
            print("Done!")
        case .failure(let error): // 에러 타입 바뀜에 따라
            print("\(error) is occured!")
        }
    }, receiveValue: { print("Got value \($0)") })
    .store(in: &subscriptions)

/*
——— Example of: map vs tryMap ———
Got value Hello World!
Done!
*/
```

### mapError

- 업스트림에서 에러를 받음
- 에러를 받아서 다른 에러로 매핑할 수 있도록 해준다.

```swift
example(of: "map vs tryMap") {

  enum NameError: Error {
    case tooShort(String)
    case unknown
  }

  Just("Hello")
    .setFailureType(to: NameError.self)
    .tryMap { throw NameError.tooShort($0) }
		// 캐스팅 실패를 할 경우에 대해서 unknown 
    .mapError { $0 as? NameError ?? .unknown }
    .sink(receiveCompletion: { completion in
        switch completion {
        case .finished:
            print("Done!")
        case .failure(let error):
            print("\(error) is occured!")
        }
    }, receiveValue: { print("Got value \($0)") })
    .store(in: &subscriptions)
}

/*
——— Example of: map vs tryMap ———
tooShort("Hello") is occured!
*/
```